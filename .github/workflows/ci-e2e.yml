name: CI - E2E

on:
  workflow_run:
    workflows: [CI - Build]
    types: [completed]
    branches: [main]
  pull_request:
    types: [opened, synchronize]

concurrency:
  group: ci-e2e-${{ github.event.workflow_run.head_sha || github.sha }}
  cancel-in-progress: true

env:
  TURBO_TOKEN: ${{ secrets.TURBO_TOKEN }}
  TURBO_TEAM: ${{ vars.TURBO_TEAM }}
  REGISTRY: ghcr.io
  API_IMAGE_NAME: ${{ github.repository }}/api

jobs:
  # For workflow_run trigger, check if CI succeeded
  check-ci:
    name: Check CI Status
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_run'
    outputs:
      should_run: ${{ steps.check.outputs.should_run }}
    steps:
      - name: Check CI workflow result
        id: check
        run: |
          if [ "${{ github.event.workflow_run.conclusion }}" == "success" ]; then
            echo "should_run=true" >> $GITHUB_OUTPUT
          else
            echo "CI workflow did not succeed, skipping E2E"
            echo "should_run=false" >> $GITHUB_OUTPUT
          fi

  # For PR trigger, wait for CI artifacts to be available
  wait-for-ci:
    name: Wait for CI
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    outputs:
      should_run: ${{ steps.wait.outputs.should_run }}
    steps:
      - name: Wait for CI workflow
        id: wait
        uses: actions/github-script@v7
        with:
          script: |
            const maxWait = 20 * 60 * 1000; // 20 minutes
            const pollInterval = 30 * 1000; // 30 seconds
            const startTime = Date.now();

            while (Date.now() - startTime < maxWait) {
              const { data: runs } = await github.rest.actions.listWorkflowRuns({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: 'ci-build.yml',
                head_sha: context.sha,
                per_page: 1
              });

              if (runs.workflow_runs.length > 0) {
                const run = runs.workflow_runs[0];
                if (run.conclusion === 'success') {
                  core.setOutput('should_run', 'true');
                  console.log('CI workflow succeeded');
                  return;
                } else if (run.conclusion && run.conclusion !== 'success') {
                  core.setOutput('should_run', 'false');
                  console.log(`CI workflow ended with: ${run.conclusion}`);
                  return;
                }
              }

              console.log('Waiting for CI workflow...');
              await new Promise(r => setTimeout(r, pollInterval));
            }

            core.setFailed('Timeout waiting for CI workflow');

  build-api-image:
    name: Build API Image
    needs: [check-ci, wait-for-ci]
    if: |
      always() &&
      (needs.check-ci.outputs.should_run == 'true' || needs.wait-for-ci.outputs.should_run == 'true')
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      actions: read
    steps:
      - uses: actions/checkout@v4
        with:
          sparse-checkout: |
            apps/api/Dockerfile
            apps/api/.dockerignore

      - name: Get CI run ID
        id: get-run
        uses: actions/github-script@v7
        with:
          script: |
            const sha = context.eventName === 'workflow_run'
              ? '${{ github.event.workflow_run.head_sha }}'
              : context.sha;

            const { data: runs } = await github.rest.actions.listWorkflowRuns({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'ci-build.yml',
              head_sha: sha,
              status: 'success',
              per_page: 1
            });

            if (runs.workflow_runs.length === 0) {
              core.setFailed('No successful CI run found');
              return;
            }

            core.setOutput('run_id', runs.workflow_runs[0].id);

      - name: Download API build artifact
        uses: actions/download-artifact@v4
        with:
          name: api-build
          path: apps/api
          github-token: ${{ secrets.GITHUB_TOKEN }}
          run-id: ${{ steps.get-run.outputs.run_id }}

      - name: Verify artifact structure
        run: |
          echo "=== apps/api directory structure ==="
          ls -la apps/api/
          echo "=== Checking for Prisma client ==="
          ls -la apps/api/node_modules/.prisma/client/ | head -5 || echo "ERROR: Prisma client not found!"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.API_IMAGE_NAME }}
          tags: |
            type=sha,prefix=,format=long
            type=ref,event=pr
            type=ref,event=branch

      - name: Build and push
        uses: docker/build-push-action@v6
        with:
          context: apps/api
          file: apps/api/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  e2e:
    name: E2E
    needs: [build-api-image]
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: read
      actions: read
    env:
      E2E_TEST_EMAIL: admin@test.com
      E2E_TEST_PASSWORD: test123
    services:
      postgres:
        image: postgres:16-alpine
        env:
          POSTGRES_USER: test
          POSTGRES_PASSWORD: test
          POSTGRES_DB: employee_db
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    steps:
      - uses: actions/checkout@v4

      - uses: ./.github/actions/setup

      - name: Get CI run ID
        id: get-run
        uses: actions/github-script@v7
        with:
          script: |
            const sha = context.eventName === 'workflow_run'
              ? '${{ github.event.workflow_run.head_sha }}'
              : context.sha;

            const { data: runs } = await github.rest.actions.listWorkflowRuns({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'ci-build.yml',
              head_sha: sha,
              status: 'success',
              per_page: 1
            });

            if (runs.workflow_runs.length === 0) {
              core.setFailed('No successful CI run found');
              return;
            }

            core.setOutput('run_id', runs.workflow_runs[0].id);

      - name: Download portal build artifact
        uses: actions/download-artifact@v4
        with:
          name: portal-build
          path: apps/portal/.next
          github-token: ${{ secrets.GITHUB_TOKEN }}
          run-id: ${{ steps.get-run.outputs.run_id }}

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Run database migrations and seed
        working-directory: apps/api
        run: |
          pnpm exec prisma migrate deploy
          pnpm exec prisma db seed
        env:
          DATABASE_URL: postgresql://test:test@localhost:5432/employee_db

      - name: Start API container and install Playwright
        run: |
          # Start Playwright install in background
          pnpm --filter @repo/portal exec playwright install --with-deps chromium &
          PLAYWRIGHT_PID=$!

          # Determine the correct SHA for image tag
          if [ "${{ github.event_name }}" == "workflow_run" ]; then
            IMAGE_SHA="${{ github.event.workflow_run.head_sha }}"
          else
            IMAGE_SHA="${{ github.sha }}"
          fi

          # Pull and start API container
          docker run -d \
            --name api \
            --network host \
            -e DATABASE_URL="postgresql://test:test@localhost:5432/employee_db" \
            -e JWT_SECRET="test-secret" \
            -e E2E_TEST_EMAIL="${{ env.E2E_TEST_EMAIL }}" \
            -e E2E_TEST_PASSWORD="${{ env.E2E_TEST_PASSWORD }}" \
            -e PORT=3002 \
            ${{ env.REGISTRY }}/${{ env.API_IMAGE_NAME }}:${IMAGE_SHA}

          # Wait for API (30 second timeout)
          echo "Waiting for API..."
          API_READY=false
          for i in {1..30}; do
            if curl -sf http://localhost:3002/health > /dev/null 2>&1; then
              echo "API ready after $i seconds!"
              API_READY=true
              break
            fi
            sleep 1
          done

          # Fail fast with logs if API not ready
          if [ "$API_READY" != "true" ]; then
            echo "::error::API failed to start within 30 seconds"
            echo "=== Container Status ==="
            docker ps -a
            echo "=== Container Logs ==="
            docker logs api 2>&1
            exit 1
          fi

          # Wait for Playwright (fail if install failed)
          if ! wait $PLAYWRIGHT_PID; then
            echo "::error::Playwright install failed"
            exit 1
          fi
          echo "Playwright ready!"

      - name: Run E2E tests
        run: pnpm --filter @repo/portal test:e2e
        env:
          NEXT_PUBLIC_API_URL: http://localhost:3002
          E2E_TEST_EMAIL: ${{ env.E2E_TEST_EMAIL }}
          E2E_TEST_PASSWORD: ${{ env.E2E_TEST_PASSWORD }}

      - uses: actions/upload-artifact@v4
        if: failure()
        with:
          name: playwright-report
          path: apps/portal/playwright-report
          retention-days: 7

      - name: Stop API container
        if: always()
        run: docker stop api || true

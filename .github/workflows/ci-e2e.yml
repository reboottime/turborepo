name: CI - E2E

on:
  workflow_run:
    workflows: [CI - Build]
    types: [completed]

concurrency:
  group: ci-e2e-${{ github.event.workflow_run.head_sha }}
  cancel-in-progress: true

env:
  TURBO_TOKEN: ${{ secrets.TURBO_TOKEN }}
  TURBO_TEAM: ${{ vars.TURBO_TEAM }}
  REGISTRY: ghcr.io
  API_IMAGE_NAME: ${{ github.repository }}/api

jobs:
  build-api-image:
    name: Build API Image
    if: github.event.workflow_run.conclusion == 'success'
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      actions: read
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.event.workflow_run.head_sha }}
          sparse-checkout: |
            apps/api/Dockerfile
            apps/api/.dockerignore

      - name: Download API build artifact
        uses: actions/download-artifact@v4
        with:
          name: api-build
          path: apps/api
          github-token: ${{ secrets.GITHUB_TOKEN }}
          run-id: ${{ github.event.workflow_run.id }}

      - name: Verify artifact structure
        run: |
          echo "=== apps/api directory structure ==="
          ls -la apps/api/
          echo "=== Checking for Prisma client ==="
          ls -la apps/api/node_modules/.prisma/client/ | head -5 || echo "ERROR: Prisma client not found!"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.API_IMAGE_NAME }}
          tags: |
            type=sha,prefix=,format=long

      - name: Build and push
        uses: docker/build-push-action@v6
        with:
          context: apps/api
          file: apps/api/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  e2e:
    name: E2E
    needs: [build-api-image]
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: read
      actions: read
    env:
      E2E_TEST_EMAIL: admin@test.com
      E2E_TEST_PASSWORD: test123
    services:
      postgres:
        image: postgres:16-alpine
        env:
          POSTGRES_USER: test
          POSTGRES_PASSWORD: test
          POSTGRES_DB: employee_db
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.event.workflow_run.head_sha }}

      - uses: ./.github/actions/setup

      - name: Download portal build artifact
        uses: actions/download-artifact@v4
        with:
          name: portal-build
          path: apps/portal/.next
          github-token: ${{ secrets.GITHUB_TOKEN }}
          run-id: ${{ github.event.workflow_run.id }}

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Run database migrations and seed
        working-directory: apps/api
        run: |
          pnpm exec prisma migrate deploy
          pnpm exec prisma db seed
        env:
          DATABASE_URL: postgresql://test:test@localhost:5432/employee_db

      - name: Start API container and install Playwright
        run: |
          # Start Playwright install in background
          pnpm --filter @repo/portal exec playwright install --with-deps chromium &
          PLAYWRIGHT_PID=$!

          # Pull and start API container
          docker run -d \
            --name api \
            --network host \
            -e DATABASE_URL="postgresql://test:test@localhost:5432/employee_db" \
            -e JWT_SECRET="test-secret" \
            -e E2E_TEST_EMAIL="${{ env.E2E_TEST_EMAIL }}" \
            -e E2E_TEST_PASSWORD="${{ env.E2E_TEST_PASSWORD }}" \
            -e PORT=3002 \
            ${{ env.REGISTRY }}/${{ env.API_IMAGE_NAME }}:${{ github.event.workflow_run.head_sha }}

          # Wait for API (30 second timeout)
          echo "Waiting for API..."
          API_READY=false
          for i in {1..30}; do
            if curl -sf http://localhost:3002/health > /dev/null 2>&1; then
              echo "API ready after $i seconds!"
              API_READY=true
              break
            fi
            sleep 1
          done

          # Fail fast with logs if API not ready
          if [ "$API_READY" != "true" ]; then
            echo "::error::API failed to start within 30 seconds"
            echo "=== Container Status ==="
            docker ps -a
            echo "=== Container Logs ==="
            docker logs api 2>&1
            exit 1
          fi

          # Wait for Playwright (fail if install failed)
          if ! wait $PLAYWRIGHT_PID; then
            echo "::error::Playwright install failed"
            exit 1
          fi
          echo "Playwright ready!"

      - name: Run E2E tests
        run: pnpm --filter @repo/portal test:e2e
        env:
          NEXT_PUBLIC_API_URL: http://localhost:3002
          E2E_TEST_EMAIL: ${{ env.E2E_TEST_EMAIL }}
          E2E_TEST_PASSWORD: ${{ env.E2E_TEST_PASSWORD }}

      - name: Visual Review (Chromatic)
        if: success() || failure()
        uses: chromaui/action@latest
        with:
          projectToken: ${{ secrets.CHROMATIC_PROJECT_TOKEN }}
          workingDir: apps/portal
          playwright: true
          exitZeroOnChanges: true
          autoAcceptChanges: main

      - uses: actions/upload-artifact@v4
        if: failure()
        with:
          name: playwright-report
          path: apps/portal/playwright-report
          retention-days: 7

      - name: Stop API container
        if: always()
        run: docker stop api || true
